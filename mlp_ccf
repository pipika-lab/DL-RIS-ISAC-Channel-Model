%初始化环境
clear; close all; clc;
rng(2024);  % 保证结果一致

% 参数设置 
j = 1i;  % 使用1i代替sqrt(-1)，更标准
f_c = 5.9e9;  
c = 3.0e8;
lambda = c / f_c;
P = 60; Q = 20; p = 1; p_p = 1; q = 1; q_q = 4;
delta_T = lambda / 2; delta_R = lambda/2;
psi_azi_T = pi/3; psi_ver_T = pi/4;
psi_azi_R = pi/3; psi_ver_R = pi/4;
eta_azi_T = pi/2; eta_ver_T = 0; eta_azi_R = pi/2;
H_0 = 0; t = 2; tt = 0;
D_0 = 100;
v_T = 10;
v_R = 15;

% cluster参数
L = 80;
xi_R_n_0 = 200;
xi_T_n_1_0 = 200;
mu_AAoA = 2*pi/3;
sigma_AAoA = 20/180*pi;
mu_EAoA = pi/6;
sigma_EAoA = 10/180*pi;
alpha_T_n_1_0 = pi/3;
beta_T_n_1_0 = pi/6; 

% RIS参数
x_RIS = 80; y_RIS = 30; z_RIS = 20;
M_x = 40; M_z = 40;
P_h = 2; P_v = 2;
d_mx = lambda/4; d_mz = lambda/4;
m_x = 1; m_z = 1;
P_h_max = 8; P_v_max = 8;
K = 1;      % 莱斯K因子，控制LoS/VLoS与NLoS的比重
alpha = 0.8; % LoS与VLoS之间的权重分配
chi_m_sub = 1;
varphi_m_sud = 1;
% 定义输入变量的范围
Nor_delta_R_rng = 0 : 0.025 : 5;
N = length(Nor_delta_R_rng);
delta_R_rng = lambda * Nor_delta_R_rng;

fprintf('正在生成 %d 个样本数据...\n', N);

% 计算理论值
% LoS路径
    rho_LoS_full = rho_CCF_pq_C(j, lambda, v_T, v_R, eta_azi_T, eta_azi_R, delta_R_rng, ...
                                delta_T, delta_R, t, tt, D_0, P, Q, p, q, p_p, q_q, ...
                                psi_ver_T, psi_azi_T, psi_ver_R, psi_azi_R);


% NLoS路径
    rho_NLoS_full = rho_CCF_cluster_C(j, lambda, v_T, v_R, eta_ver_T, eta_azi_T, delta_R_rng, ...
                                      eta_azi_R, t, tt, xi_R_n_0, D_0, H_0, P, Q, p, q, p_p, q_q, ...
                                      delta_T, delta_R, mu_AAoA, sigma_AAoA, mu_EAoA, sigma_EAoA, ...
                                      psi_ver_T, psi_azi_T, psi_ver_R, psi_azi_R);

% VLoS路径
% chi_m_sub = 0.8 + 0.2*rand();
% varphi_m_sud = 2*pi*rand();

    rho_VLoS_full = rho_CCF_RIS_C(j, lambda, v_T, v_R, eta_ver_T, eta_azi_T, eta_azi_R, delta_T, delta_R_rng, ...
                                  delta_R, t, tt, D_0, H_0, P, Q, p, q, p_p, q_q, P_h, P_v, P_h_max, P_v_max, m_x, m_z,...
                                  psi_ver_T, psi_azi_T, psi_ver_R, psi_azi_R, chi_m_sub, varphi_m_sud);
abs_rho_NLoS_C = abs(rho_NLoS_full);
abs_rho_VLoS_C = abs(rho_VLoS_full);
abs_rho_LoS_C  = abs(rho_LoS_full);

% 对幅度进行加权平均（非相干叠加）
smooth_mixed_C = (1)/(K+1) * abs_rho_NLoS_C + ...
                 (K)/(K+1) * (alpha * abs_rho_VLoS_C + (1 - alpha) * abs_rho_LoS_C);

% 归一化处理，得到最终的光滑混合曲线
rho_CCF_LoS_cluster_RIS_C = smooth_mixed_C / smooth_mixed_C(1);
% 检查数据维度
fprintf('rho_LoS_full 大小: %s\n', mat2str(size(rho_LoS_full)));
fprintf('rho_NLoS_full 大小: %s\n', mat2str(size(rho_NLoS_full)));
fprintf('rho_VLoS_full 大小: %s\n', mat2str(size(rho_VLoS_full)));
fprintf('rho_CCF_LoS_cluster_RIS_C 大小: %s\n', mat2str(size(rho_CCF_LoS_cluster_RIS_C)));
% 确保所有数据都是行向量
if size(rho_LoS_full, 1) > 1
    rho_LoS_full = rho_LoS_full.';
end
if size(rho_NLoS_full, 1) > 1
    rho_NLoS_full = rho_NLoS_full.';
end
if size(rho_VLoS_full, 1) > 1
    rho_VLoS_full = rho_VLoS_full.';
end
if size(rho_CCF_LoS_cluster_RIS_C, 1) > 1
    rho_CCF_LoS_cluster_RIS_C = rho_CCF_LoS_cluster_RIS_C.';
end
% === 数据质量检查和修复 ===
fprintf('\n=== 数据质量检查 ===\n');
fprintf('LoS数据范围: [%.6f, %.6f]\n', min(abs(rho_LoS_full)), max(abs(rho_LoS_full)));
fprintf('NLoS数据范围: [%.6f, %.6f]\n', min(abs(rho_NLoS_full)), max(abs(rho_NLoS_full)));
fprintf('VLoS数据范围: [%.6f, %.6f]\n', min(abs(rho_VLoS_full)), max(abs(rho_VLoS_full)));
fprintf('rho_CCF_LoS_cluster_RIS_C数据范围: [%.6f, %.6f]\n', min(abs(rho_CCF_LoS_cluster_RIS_C)), max(abs(rho_CCF_LoS_cluster_RIS_C)));

% 生成训练数据集 - 改进的策略
num_samples = 1000;  % 增加样本数量
inputs = zeros(12, num_samples);  % 增加到12维输入特征
targets = zeros(4, num_samples);   % 3个输出（LoS, NLoS, VLoS）


   sample_weights = ones(1, num_samples);%初始化样本
   fprintf('正在生成 %d 个训练样本...\n', num_samples);
for i = 1:num_samples
    r = rand(); % 生成一个随机数来决定路径类型
    if r < 0.25  % 25% LoS
        path_focus = 1;
        noise_scale = [0.005, 0.02, 0.02, 0.01];
        sample_weights(i) = 3.0;
    elseif r < 0.50 % 25% NLoS
        path_focus = 2;
        noise_scale = [0.01, 0.005, 0.02, 0.01];
        sample_weights(i) = 1.0;
    elseif r < 0.75 % 25% VLoS
        path_focus = 3;
        noise_scale = [0.01, 0.02, 0.005, 0.01];
        sample_weights(i) = 1.0;
    else % 25% 混合路径
        path_focus = 4;
        noise_scale = [0.01, 0.01, 0.01, 0.005]; % 给混合路径本身最小的噪声
        sample_weights(i) = 2.0; % 混合路径也比较重要，给中等权重
    end
    idx = randi(N); % 使用随机采样简化，您的智能采样函数也可保留
    nor_delta_R = Nor_delta_R_rng(idx); 

    v_T_sample = 5 + 10 * rand(); v_R_sample = 3 + 9 * rand();
    D_0_sample = 50 + 150 * rand();
    psi_azi_T_sample = pi/6 + pi/3 * rand(); psi_azi_R_sample = pi/6 + pi/3 * rand();
    psi_ver_T_sample = pi/8 + pi/4 * rand(); psi_ver_R_sample = pi/8 + pi/4 * rand();
    
    % RIS参数随机化
    chi_m_sub_sample = 1;
    
    % 构造更丰富的输入特征向量
    inputs(:, i) = [
        nor_delta_R;                              % 1. 归一化天线间距
        v_T_sample/c;                             % 2. 归一化发射端速度
        v_R_sample/c;                             % 3. 归一化接收端速度
        D_0_sample/lambda;                        % 4. 归一化距离
        psi_azi_T_sample;                         % 5. 发射端方位角
        psi_azi_R_sample;                         % 6. 接收端方位角
        cos(psi_azi_T_sample);                    % 7. 余弦特征
        sin(psi_azi_R_sample);                    % 8. 正弦特征
        path_focus;                               % 9. 路径类型标识
        nor_delta_R^2;                            % 10. 二次特征
        nor_delta_R * cos(psi_azi_T_sample);      % 11. 交互特征1
        sqrt(nor_delta_R + eps);                  % 12. 平方根特征
    ];
    
    % 对应的理论输出值
    base_targets = [
        abs(rho_LoS_full(idx));
        abs(rho_NLoS_full(idx));
        abs(rho_VLoS_full(idx));
        abs(rho_CCF_LoS_cluster_RIS_C(idx));
    ];
    
    % 添加适应性噪声
    for k = 1:4
        noise = noise_scale(k) * randn();
        targets(k, i) = max(0, base_targets(k) * (1 + noise));
    end
end

fprintf('数据生成完毕。输入矩阵大小: %s, 目标矩阵大小: %s\n', ...
        mat2str(size(inputs)), mat2str(size(targets)));

%% 数据预处理
% 输入标准化 - 使用z-score标准化
input_mean = mean(inputs, 2);
input_std = std(inputs, 0, 2) + eps;
inputs_normalized = (inputs - input_mean) ./ input_std;

% 输出标准化 - 分别处理每种路径
target_mean = mean(targets, 2);
target_std = std(targets, 0, 2) + eps;
targets_normalized = (targets - target_mean) ./ target_std;

% 针对性数据增强
augment_ratio = 0.15;
num_augment = round(augment_ratio * num_samples);

% 重点增强LoS路径数据
los_indices = find(inputs(9,:) == 1);  % 找到LoS样本
if ~isempty(los_indices)
    % 选择LoS样本进行增强
    aug_los_count = round(0.6 * num_augment);  % 60%的增强样本来自LoS
    aug_los_indices = los_indices(randi(length(los_indices), 1, aug_los_count));
    
    % 其余样本随机选择
    remaining_indices = setdiff(1:num_samples, los_indices);
    aug_other_indices = remaining_indices(randi(length(remaining_indices), 1, num_augment - aug_los_count));
    
    aug_indices = [aug_los_indices, aug_other_indices];
else
    aug_indices = randi(num_samples, 1, num_augment);
end

inputs_aug = inputs_normalized(:, aug_indices) + 0.05 * randn(size(inputs_normalized, 1), num_augment);
targets_aug = targets_normalized(:, aug_indices) + 0.02 * randn(size(targets_normalized, 1), num_augment);

% 合并原始和增强数据
inputs_final = [inputs_normalized, inputs_aug];
targets_final = [targets_normalized, targets_aug];

fprintf('增强后数据大小: %s\n', mat2str(size(inputs_final)));

%% 改进的网络设计与训练
% 调整网络架构 - 考虑到LoS路径的特殊性
hiddenLayerSize = [80, 60, 40, 20];  % 稍微增大网络容量
net = feedforwardnet(hiddenLayerSize, 'trainlm');

% 网络配置
net.input.processFcns = {};
net.output.processFcns = {};

% 优化的训练参数
net.trainParam.epochs = 800;           % 增加最大训练轮数
net.trainParam.max_fail = 50;          % 适中的早停容忍度
net.trainParam.min_grad = 1e-10;       
net.trainParam.mu = 0.001;             
net.trainParam.mu_dec = 0.1;           
net.trainParam.mu_inc = 10;            
net.trainParam.mu_max = 1e10;          
net.performFcn = 'mse';
net.trainParam.goal = 1e-12;           
net.trainParam.show = 25;              
net.trainParam.showWindow = true;      
net.trainParam.showCommandLine = true; 

% 激活函数设置 - 混合激活函数
for i = 1:length(hiddenLayerSize)
    if i <= 2
        net.layers{i}.transferFcn = 'tansig'; % 前两层使用tansig
    else
        net.layers{i}.transferFcn = 'logsig'; % 后面层使用logsig
    end
end
net.layers{end}.transferFcn = 'purelin'; % 输出层

% 数据集划分 - 确保LoS样本在各集合中都有代表
net.divideFcn = 'dividerand';
net.divideParam.trainRatio = 0.80;     
net.divideParam.valRatio = 0.10;       
net.divideParam.testRatio = 0.10;      

% 权重初始化
net = init(net);

% 使用Xavier初始化
for i = 1:length(net.layers)
    if ~isempty(net.IW{i,1})
        [fan_in, fan_out] = size(net.IW{i,1});
        limit = sqrt(6 / (fan_in + fan_out));
        net.IW{i,1} = 2 * limit * rand(size(net.IW{i,1})) - limit;
    end
    for j = 1:length(net.layers)
        if ~isempty(net.LW{i,j})
            [fan_in, fan_out] = size(net.LW{i,j});
            limit = sqrt(6 / (fan_in + fan_out));
            net.LW{i,j} = 2 * limit * rand(size(net.LW{i,j})) - limit;
        end
    end
end

% 执行训练
[net, tr] = train(net, inputs_final, targets_final);
fprintf('训练完成，实际轮数: %d\n', tr.num_epochs);

%% 模型测试和评估
% 使用原始理论数据进行测试
test_inputs = zeros(12, N);
for i = 1:N
    test_inputs(:, i) = [
        Nor_delta_R_rng(i);
        v_T/c;
        v_R/c;
        D_0/lambda;
        psi_azi_T;
        psi_azi_R;
        cos(psi_azi_T);        sin(psi_azi_R);
        4;  % 混合路径类型
        Nor_delta_R_rng(i)^2;
        Nor_delta_R_rng(i) * cos(psi_azi_T);
        sqrt(Nor_delta_R_rng(i) + eps);
    ];
end

% 标准化测试输入
test_inputs_normalized = (test_inputs - input_mean) ./ input_std;

% 预测
predictions_normalized = net(test_inputs_normalized);

% 反标准化
predictions = predictions_normalized .* target_std + target_mean;
predictions = max(predictions, 0); % 确保非负

% 理论值输出
theory_values = [
    abs(rho_LoS_full);
    abs(rho_NLoS_full);
    abs(rho_VLoS_full);
    abs(rho_CCF_LoS_cluster_RIS_C);
];

%% 结果可视化
sample_step = 5;  % 调整这个值控制稀疏程度
Nor_delta_R_rng_sparse = Nor_delta_R_rng(1:sample_step:end);
figure('Position', [100, 100, 1000, 1000]);
hold on;

% 路径信息
path_names = {'LoS, C', 'NLoS, C', 'VLoS, C', 'LoS+NLoS+VLoS, C'};
colors = {'b', 'g', 'r', 'm'};

% 绘图并计算性能指标
for k = 1:4
    % 绘制理论与预测曲线
    plot(Nor_delta_R_rng, theory_values(k,:), [colors{k} '-'], 'LineWidth', 2, 'DisplayName', sprintf('%s (Theroy)', path_names{k}));
    pred_sparse = predictions(k,1:sample_step:end);
    plot(Nor_delta_R_rng_sparse, pred_sparse, [colors{k} 'o'], 'LineWidth', 1.5, 'DisplayName', sprintf('%s (MLP-NN)', path_names{k}));
    
    % 计算RMSE
    y_true = theory_values(k,:);
    y_pred = predictions(k,:);
    RMSE = sqrt(mean((y_true - y_pred).^2));
    
    % 在图中添加 RMSE 标注（使用相对位置）
    x_text_pos = 0.70;
    y_text_pos = 0.90 - 0.05 * (k-1);  % 分层排布
    text(x_text_pos, y_text_pos, ...
        sprintf('%s RMSE = %.4f', path_names{k}, RMSE), ...
        'Units', 'normalized', ...
        'FontSize', 16, 'Color', colors{k}, ...
        'BackgroundColor', 'white', 'EdgeColor', 'black', 'Margin', 3);
end

% 图属性设置
xlabel('Normalized antenna spacing, $\delta_R/\lambda$', 'Interpreter', 'latex');
ylabel('Spatial CCFs');
legend('Location', 'best', 'FontSize', 16);
grid on;
xlim([0, 5]);
ylim([0, 1]);
box on

%% 保存模型和结果
fprintf('保存训练好的模型...\n');
save('CCF_MLP_model_C.mat', 'net', 'tr', 'input_mean', 'input_std', 'target_mean', 'target_std', ...
     'inputs_final', 'targets_final', 'predictions', 'theory_values', 'Nor_delta_R_rng');

%% 训练过程可视化 
% figure('Position', [1500, 100, 800, 600]);
% plotperform(tr);
% title('优化后训练过程性能曲线');

% 显示最终训练结果
fprintf('\n=== 优化后训练结果摘要 ===\n');
fprintf('训练样本数: %d\n', size(inputs_final, 2));
fprintf('网络架构: %s\n', mat2str(hiddenLayerSize));
fprintf('训练轮数: %d\n', tr.num_epochs);
fprintf('最终训练误差: %.8f\n', tr.perf(end));
fprintf('最终验证误差: %.8f\n', tr.vperf(end));
fprintf('最终测试误差: %.8f\n', tr.tperf(end));
% fprintf('各路径预测精度 (R²): LoS=%.4f, NLoS=%.4f, VLoS=%.4f\n', overall_R2);
% fprintf('平均预测精度 (R²): %.4f\n', mean(overall_R2));
% 
% if overall_R2(1) > 0.8
%     fprintf('✓ LoS路径预测效果良好！\n');
% elseif overall_R2(1) > 0.5
%     fprintf('△ LoS路径预测效果中等，可能需要进一步优化\n');
% else
%     fprintf('✗ LoS路径预测效果仍需改进\n');
% end

fprintf('\n模型优化训练完成！\n');

%初始化环境
clear; close all; clc;
rng(2024);
% 参数设置
j = 1i;  % 使用1i代替sqrt(-1)，更标准
f_c = 5.9e9;
c = 3.0e8;
lambda = c / f_c;
sigma = 1.5;
P = 60; P_s = 20; p = 1; p_p = 1; p_s = 1; p_s_p_s = 4;
delta_T = lambda / 2; delta_T_s = lambda/2;
psi_azi_T = pi/3; psi_ver_T = pi/4;
psi_azi_T_s = pi/4; psi_ver_T_s = pi/6;
eta_azi_T = pi/2; eta_ver_T = 0; eta_azi_R = pi/2;
H_0 = 0; t = 2; tt = 0;
D_0 = 100;
v_T = 40;
v_R = 20;
% cluster参数
L = 80;
xi_R_n_0 = 200;
xi_T_n_1_0 = 200;
mu_AAoA = 2*pi/3;
sigma_AAoA = 20/180*pi;
mu_EAoA = pi/6;
sigma_EAoA = 10/180*pi;
alpha_T_n_1_0 = pi/3;
beta_T_n_1_0 = pi/6;
% RIS参数
x_RIS = 80; y_RIS = 30; z_RIS = 20;
chi_m_sub = 1;
varphi_m_sud = 1;
x_m_sub = 80;                                 % O --> m_sub-th sub-array in RIS
y_m_sub = 30;                                     
z_m_sub = 20; 
K = 1;      % 莱斯K因子，控制LoS/VLoS与NLoS的比重
alpha = 0.6; % LoS与VLoS之间的权重分配
% --- 输入范围 ---
Nor_delta_T_s_rng = 0 : 0.25 : 4;
N = length(Nor_delta_T_s_rng);
delta_T_s_rng = lambda * Nor_delta_T_s_rng;
fprintf('正在生成 %d 个样本数据...\n', N);
% 计算理论值
rho_LoS_S = rho_CCF_pq_S(j, lambda, v_T, v_R, eta_azi_T, eta_azi_R, delta_T_s_rng, ...
                                        delta_T, delta_T_s, t, tt, D_0, P, P_s, p, p_s, p_p, p_s_p_s, ...
                                        psi_ver_T, psi_azi_T, psi_ver_T_s, psi_azi_T_s);
rho_NLoS_S = rho_CCF_cluster_S(j, lambda, v_T, eta_azi_T, delta_T_s_rng, ...
                                        delta_T, delta_T_s, t, tt, xi_T_n_1_0, D_0, P, P_s, p, p_s, p_p, p_s_p_s, ...
                                        mu_AAoA, sigma_AAoA, mu_EAoA, sigma_EAoA, psi_ver_T, psi_azi_T, psi_ver_T_s, psi_azi_T_s);
rho_VLoS_S = rho_CCF_RIS_S(j, lambda, sigma, v_T, eta_azi_T, delta_T_s_rng, delta_T, delta_T_s, t, tt, ...
                                                x_m_sub, y_m_sub, z_m_sub, H_0,P, P_s, p, p_s, p_p, p_s_p_s,  ...
                                                psi_ver_T, psi_azi_T, psi_ver_T_s, psi_azi_T_s, chi_m_sub, varphi_m_sud);

abs_rho_NLoS_S = abs(rho_NLoS_S);
abs_rho_VLoS_S = abs(rho_VLoS_S); 
abs_rho_LoS_S  = abs(rho_LoS_S);

% 对幅度进行加权平均（非相干叠加）
% 注意这里的权重是功率域的，所以直接用 K/(K+1) 和 1/(K+1)
smooth_mixed_S = (1)/(K+1) * abs_rho_NLoS_S + ...
                 (K)/(K+1) * (alpha * abs_rho_VLoS_S + (1 - alpha) * abs_rho_LoS_S);

% 归一化处理，得到最终的光滑混合曲线
rho_CCF_LoS_cluster_RIS_S = smooth_mixed_S / smooth_mixed_S(1);
fprintf('理论数据生成完毕。\n\n');
% 数据质量检查
fprintf('rho_LoS_S 大小: %s\n', mat2str(size(rho_LoS_S)));
fprintf('rho_NLoS_S 大小: %s\n', mat2str(size(rho_NLoS_S)));
fprintf('rho_VLoS_S 大小: %s\n', mat2str(size(rho_VLoS_S)));
fprintf('rho_CCF_LoS_cluster_RIS_S 大小: %s\n', mat2str(size(rho_CCF_LoS_cluster_RIS_S)));
% 确保行向量
if size(rho_LoS_S, 1) > 1, rho_LoS_S = rho_LoS_S.'; end
if size(rho_NLoS_S, 1) > 1, rho_NLoS_S = rho_NLoS_S.'; end
if size(rho_VLoS_S, 1) > 1, rho_VLoS_S = rho_VLoS_S.'; end
if size(rho_CCF_LoS_cluster_RIS_S, 1) > 1, rho_CCF_LoS_cluster_RIS_S = rho_CCF_LoS_cluster_RIS_S.'; end
fprintf('LoS数据范围: [%.6f, %.6f]\n', min(abs(rho_LoS_S)), max(abs(rho_LoS_S)));
fprintf('NLoS数据范围: [%.6f, %.6f]\n', min(abs(rho_NLoS_S)), max(abs(rho_NLoS_S)));
fprintf('VLoS数据范围: [%.6f, %.6f]\n', min(abs(rho_VLoS_S)), max(abs(rho_VLoS_S)));
fprintf('rho_CCF_LoS_cluster_RIS_S数据范围: [%.6f, %.6f]\n', min(abs(rho_CCF_LoS_cluster_RIS_S)), max(abs(rho_CCF_LoS_cluster_RIS_S)));

%% 训练模型
num_samples = 2000; % 增加样本以提高泛化能力
inputs = zeros(12, num_samples);  % 12维输入特征
targets = zeros(4, num_samples);  % 3个输出(LoS, NLoS, VLoS)
sample_weights = ones(1, num_samples);%初始化样本
fprintf('正在生成 %d 个训练样本...\n', num_samples);
for i = 1:num_samples
    r = rand(); % 生成一个随机数来决定路径类型
    if r < 0.25  % 25% LoS
        path_focus = 1;
        noise_scale = [0.005, 0.02, 0.02, 0.01];
        sample_weights(i) = 3.0;
    elseif r < 0.50 % 25% NLoS
        path_focus = 2;
        noise_scale = [0.01, 0.005, 0.02, 0.01];
        sample_weights(i) = 1.0;
    elseif r < 0.75 % 25% VLoS
        path_focus = 3;
        noise_scale = [0.01, 0.02, 0.005, 0.01];
        sample_weights(i) = 1.0;
    else % 25% 混合路径
        path_focus = 4;
        noise_scale = [0.01, 0.01, 0.01, 0.005]; % 给混合路径本身最小的噪声
        sample_weights(i) = 2.0; % 混合路径也比较重要，给中等权重
    end
    idx = randi(N); % 使用随机采样简化，您的智能采样函数也可保留
    nor_delta_T_s = Nor_delta_T_s_rng(idx);

% 参数扰动 (感知信道特有参数)
if path_focus == 1  % LoS路径
    v_T_sample = v_T + 1*randn();
    D_0_sample = max(80, D_0 + 10*randn());
    psi_azi_T_sample = psi_azi_T + 0.1*randn();
    psi_ver_T_sample = psi_ver_T + 0.1*randn();
    psi_azi_T_s_sample = psi_azi_T_s + 0.1*randn();  % 感知特有角度
    psi_ver_T_s_sample = psi_ver_T_s + 0.1*randn();
else
    v_T_sample = v_T + 3*randn();
    D_0_sample = max(50, D_0 + 20*randn());
    psi_azi_T_sample = psi_azi_T + 0.2*randn();
    psi_ver_T_sample = psi_ver_T + 0.2*randn();
    psi_azi_T_s_sample = psi_azi_T_s + 0.2*randn();
    psi_ver_T_s_sample = psi_ver_T_s + 0.1*randn();
end

% % RIS参数随机化
chi_m_sub_sample = 1 - 0.1 * rand(); % 引入0.9-1.0的轻微损耗
% varphi_m_sud_sample = 0 + (pi/4) * (rand() - 0.5); % 引入小范围的相位误差

% 构造输入特征 (包含感知特有参数)
inputs(:, i) = [
    nor_delta_T_s;                          % 1. 归一化天线间距
    v_T_sample/c;                           % 2. 归一化发射端速度
    D_0_sample/lambda;                      % 3. 归一化距离
    psi_azi_T_sample;                       % 4. 发射端方位角
    psi_azi_T_s_sample;                     % 5. 感知端方位角(特有)
    cos(psi_azi_T_sample - psi_azi_T_s_sample); % 6. 角度差余弦
    path_focus;                             % 7. 路径类型标识
    nor_delta_T_s^2;                        % 8. 二次特征
    sigma;                                  % 9. 感知特有参数
    sqrt(nor_delta_T_s + eps);              % 10. 平方根特征
    chi_m_sub_sample;                       % 11. RIS反射系数
    (psi_ver_T_sample + psi_ver_T_s_sample)/2; % 12. 平均仰角
];

% 理论输出值
base_targets = [
    abs(rho_LoS_S(idx));
    abs(rho_NLoS_S(idx));
    abs(rho_VLoS_S(idx));
    abs(rho_CCF_LoS_cluster_RIS_S(idx));
];

% 添加适应性噪声
for k = 1:4
    noise = noise_scale(k) * randn();
    targets(k, i) = max(0, base_targets(k) * (1 + noise));
end
end
%% 4. 数据预处理
% 输入标准化
input_mean = mean(inputs, 2);
input_std = std(inputs, 0, 2) + eps;
inputs_normalized = (inputs - input_mean) ./ input_std;
% 输出标准化
target_mean = mean(targets, 2);
target_std = std(targets, 0, 2) + eps;
targets_normalized = (targets - target_mean) ./ target_std;
% 数据增强 (15%增强样本)
num_augment = round(0.15 * num_samples);
aug_indices = randi(num_samples, 1, num_augment);
inputs_aug = inputs_normalized(:, aug_indices) + 0.05 * randn(size(inputs_normalized, 1), num_augment);
targets_aug = targets_normalized(:, aug_indices) + 0.02 * randn(size(targets_normalized, 1), num_augment);
weights_aug = sample_weights(aug_indices); % 增强样本继承原始权重
% 合并数据
inputs_final = [inputs_normalized, inputs_aug];
targets_final = [targets_normalized, targets_aug];
weights_final = [sample_weights, weights_aug]; % 合并权重
fprintf('最终数据集大小: %s\n', mat2str(size(inputs_final)));
%% 5. MLP模型设计 (针对感知信道优化)
% hiddenLayerSize = [64, 48, 32];  % 稍小的网络规模
hiddenLayerSize = [80, 60, 40, 20];  % 稍微增大网络容量
net = feedforwardnet(hiddenLayerSize, 'trainlm');
% 网络配置
net.input.processFcns = {};
net.output.processFcns = {};
% 训练参数
net.trainParam.epochs = 600;
net.trainParam.max_fail = 35;
net.trainParam.min_grad = 1e-8;
net.performFcn = 'mse';
% 激活函数设置
net.layers{1}.transferFcn = 'tansig';
net.layers{2}.transferFcn = 'tansig';
net.layers{3}.transferFcn = 'logsig';  % 输出层前使用logsig
net.layers{end}.transferFcn = 'purelin';
% 数据集划分
net.divideFcn = 'dividerand';
net.divideParam.trainRatio = 0.80;
net.divideParam.valRatio = 0.10;
net.divideParam.testRatio = 0.10;
% 权重初始化 (Xavier)
for i = 1:length(net.layers)
if ~isempty(net.IW{i,1})
[fan_in, fan_out] = size(net.IW{i,1});
limit = sqrt(6 / (fan_in + fan_out));
net.IW{i,1} = 2 * limit * rand(size(net.IW{i,1})) - limit;
end
for j = 1:length(net.layers)
if ~isempty(net.LW{i,j})
[fan_in, fan_out] = size(net.LW{i,j});
limit = sqrt(6 / (fan_in + fan_out));
net.LW{i,j} = 2 * limit * rand(size(net.LW{i,j})) - limit;
end
end
end
%% 6. 模型训练
fprintf('开始训练感知信道MLP...\n');
[net, tr] = train(net, inputs_final, targets_final, [], [], weights_final);
fprintf('训练完成，实际轮数: %d\n', tr.num_epochs);
figure('Name','Training Performance','NumberTitle','off');
plotperform(tr);
%% 7. 模型测试
for k = 1:4 % 循环LoS, NLoS, VLoS
    % 准备当前路径的测试输入
    test_inputs_k = zeros(12, N);
    for i = 1:N
        test_inputs_k(:, i) = [
            Nor_delta_T_s_rng(i); v_T/c; D_0/lambda;
            psi_azi_T; psi_azi_T_s; cos(psi_azi_T - psi_azi_T_s);
            k;  
            Nor_delta_T_s_rng(i)^2; sigma; sqrt(Nor_delta_T_s_rng(i) + eps);
            chi_m_sub; (psi_ver_T + psi_ver_T_s)/2;
        ];
    end

    % 标准化测试输入
    test_inputs_normalized_k = (test_inputs_k - input_mean) ./ input_std;

    % 预测 (得到的是标准化的预测值)
    predictions_normalized_k = net(test_inputs_normalized_k);

    % 反标准化，得到真实的预测值
    predictions_k = predictions_normalized_k .* target_std + target_mean;

    % 物理约束，确保值在0和1之间
    predictions_k = max(0, min(1, predictions_k));

    % 当前路径对应的那个输出
    predictions(k, :) = predictions_k(k, :);
end
% 理论值
theory_values = [
abs(rho_LoS_S);
abs(rho_NLoS_S);
abs(rho_VLoS_S);
abs(rho_CCF_LoS_cluster_RIS_S);
];

%% 8. 结果可视化
% sample_step = 2;  % 调整这个值控制稀疏程度
% Nor_delta_T_s_rng_sparse = Nor_delta_T_s_rng(1:sample_step:end);
figure('Position', [100, 100, 100, 100]);
hold on;

% 路径信息
path_names = {'LoS, S', 'NLoS, S', 'VLoS, S', 'LoS+NLoS+VLoS, S'};
colors = {'b', 'c', 'm', 'g'};

% 绘图并计算性能指标
for k = 1:4
    % 绘制理论与预测曲线
    plot(Nor_delta_T_s_rng, theory_values(k,:), [colors{k} '-'], 'LineWidth', 2, 'DisplayName', sprintf('%s (Theroy)', path_names{k}));
    % pred_sparse = predictions(k,1:sample_step:end);
    % plot(Nor_delta_T_s_rng_sparse, pred_sparse,[colors{k} '--h'], 'LineWidth', 1.5, 'DisplayName', sprintf('%s (MLP-NN)', path_names{k}));
    plot(Nor_delta_T_s_rng, predictions(k, :),[colors{k} '--o'], 'LineWidth', 1.5, 'DisplayName', sprintf('%s (MLP-NN)', path_names{k}));
    % 计算RMSE
    y_true = theory_values(k,:);
    y_pred = predictions(k,:);
    RMSE = sqrt(mean((y_true - y_pred).^2));
    
    % 在图中添加 RMSE 标注（使用相对位置）
    x_text_pos = 0.75;
    y_text_pos = 0.85 - 0.05 * (k-1);  % 分层排布
    text(x_text_pos, y_text_pos, ...
        sprintf('%s RMSE = %.4f', path_names{k}, RMSE), ...
        'Units', 'normalized', ...
        'FontSize', 16, 'Color', colors{k}, ...
        'BackgroundColor', 'white', 'EdgeColor', 'black', 'Margin', 3);
end

% 图属性设置
xlabel('Normalized antenna spacing, $\delta_S/\lambda$', 'Interpreter', 'latex');
ylabel('Spatial CCFs');
legend('Location', 'best', 'FontSize', 16);
grid on;
xlim([0, 4]);
ylim([0, 1]);
box on
% disp(size(theory_values));
% disp(theory_values);
% disp(length(Nor_delta_T_s_rng));
% disp(max(theory_values(k,:)))

%% 9. 保存模型
model_filename = 'CCF_MLP_model_S.mat';
fprintf('保存感知信道模型到 %s...\n', model_filename);
save(model_filename, 'net', 'tr', 'input_mean', 'input_std', 'target_mean', 'target_std', ...
'Nor_delta_T_s_rng', 'theory_values', 'predictions');

